"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/implementations/multicall";
exports.ids = ["pages/api/implementations/multicall"];
exports.modules = {

/***/ "ethers":
/*!*************************!*\
  !*** external "ethers" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("ethers");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "axios":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

module.exports = import("axios");;

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fimplementations%2Fmulticall&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fimplementations%2Fmulticall.js&middlewareConfigBase64=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fimplementations%2Fmulticall&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fimplementations%2Fmulticall.js&middlewareConfigBase64=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_implementations_multicall_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/api/implementations/multicall.js */ \"(api)/./pages/api/implementations/multicall.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_implementations_multicall_js__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_implementations_multicall_js__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_implementations_multicall_js__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_implementations_multicall_js__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/implementations/multicall\",\n        pathname: \"/api/implementations/multicall\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_implementations_multicall_js__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmltcGxlbWVudGF0aW9ucyUyRm11bHRpY2FsbCZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnBhZ2VzJTJGYXBpJTJGaW1wbGVtZW50YXRpb25zJTJGbXVsdGljYWxsLmpzJm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNMO0FBQzFEO0FBQ3FFO0FBQ3JFO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyxvRUFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyxlQUFlLHdFQUFLLENBQUMsb0VBQVE7QUFDcEM7QUFDTyx3QkFBd0IsZ0hBQW1CO0FBQ2xEO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVELHFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmF5Yy1ldGgtc3VtLz9mZDQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhZ2VzQVBJUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9wYWdlcy1hcGkvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgaG9pc3QgfSBmcm9tIFwibmV4dC9kaXN0L2J1aWxkL3RlbXBsYXRlcy9oZWxwZXJzXCI7XG4vLyBJbXBvcnQgdGhlIHVzZXJsYW5kIGNvZGUuXG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiLi9wYWdlcy9hcGkvaW1wbGVtZW50YXRpb25zL211bHRpY2FsbC5qc1wiO1xuLy8gUmUtZXhwb3J0IHRoZSBoYW5kbGVyIChzaG91bGQgYmUgdGhlIGRlZmF1bHQgZXhwb3J0KS5cbmV4cG9ydCBkZWZhdWx0IGhvaXN0KHVzZXJsYW5kLCBcImRlZmF1bHRcIik7XG4vLyBSZS1leHBvcnQgY29uZmlnLlxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IGhvaXN0KHVzZXJsYW5kLCBcImNvbmZpZ1wiKTtcbi8vIENyZWF0ZSBhbmQgZXhwb3J0IHRoZSByb3V0ZSBtb2R1bGUgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuZXhwb3J0IGNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IFBhZ2VzQVBJUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLlBBR0VTX0FQSSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2ltcGxlbWVudGF0aW9ucy9tdWx0aWNhbGxcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9pbXBsZW1lbnRhdGlvbnMvbXVsdGljYWxsXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogXCJcIixcbiAgICAgICAgZmlsZW5hbWU6IFwiXCJcbiAgICB9LFxuICAgIHVzZXJsYW5kXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZXMtYXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fimplementations%2Fmulticall&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fimplementations%2Fmulticall.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./pages/api/implementations/multicall.js":
/*!************************************************!*\
  !*** ./pages/api/implementations/multicall.js ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"ethers\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ethers__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"axios\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([axios__WEBPACK_IMPORTED_MODULE_1__]);\naxios__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// Multicall implementation - batches ETH balance queries for maximum efficiency\n\n\n\n\n// Constants\nconst BAYC_CONTRACT_ADDRESS = \"0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D\";\nconst ETHERSCAN_API_URL = \"https://api.etherscan.io/api\";\nconst ETHERSCAN_API_KEY = process.env.ETHERSCAN_API_KEY || \"\";\nconst ALCHEMY_API_KEY = process.env.ALCHEMY_API_KEY || \"\";\nconst ALCHEMY_API_URL = `https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`;\n// Multicall Contract Addresses\nconst MULTICALL_ADDRESS = \"0xcA11bde05977b3631167028862bE2a173976CA11\"; // Multicall3 contract\n// ABI for Multicall3\nconst MULTICALL_ABI = [\n    \"function aggregate(tuple(address target, bytes callData)[] calls) view returns (uint256 blockNumber, bytes[] returnData)\",\n    \"function blockAndAggregate(tuple(address target, bytes callData)[] calls) view returns (uint256 blockNumber, bytes32 blockHash, tuple(bool success, bytes returnData)[] returnData)\",\n    \"function getBlockHash(uint256 blockNumber) view returns (bytes32 blockHash)\",\n    \"function getBlockNumber() view returns (uint256 blockNumber)\",\n    \"function getCurrentBlockCoinbase() view returns (address coinbase)\",\n    \"function getCurrentBlockDifficulty() view returns (uint256 difficulty)\",\n    \"function getCurrentBlockGasLimit() view returns (uint256 gaslimit)\",\n    \"function getCurrentBlockTimestamp() view returns (uint256 timestamp)\",\n    \"function getEthBalance(address addr) view returns (uint256 balance)\",\n    \"function getLastBlockHash() view returns (bytes32 blockHash)\",\n    \"function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[] returnData)\",\n    \"function aggregate3Value(tuple(address target, bool allowFailure, bytes callData, uint256 value)[] calls) payable returns (tuple(bool success, bytes returnData)[] returnData)\",\n    \"function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[] returnData)\",\n    \"function tryBlockAndAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) view returns (uint256 blockNumber, bytes32 blockHash, tuple(bool success, bytes returnData)[] returnData)\"\n];\n// Graph API endpoint for BAYC data\nconst GRAPH_URL = process.env.BAYC_SUBGRAPH_URL;\n// Static provider as reliable fallback\nconst STATIC_PROVIDER = new ethers__WEBPACK_IMPORTED_MODULE_0__.ethers.providers.StaticJsonRpcProvider(ALCHEMY_API_URL);\n// Results storage - persist between restarts\nconst RESULTS_FILE_PATH = path__WEBPACK_IMPORTED_MODULE_3___default().join(process.cwd(), \"data\", \"results.json\");\n// Removed public RPC endpoints since we're only using Alchemy now\n// Fallback data for when network is unavailable\nconst FALLBACK_DEMO_DATA = {\n    // Example timestamp -> block mapping\n    blocks: {\n        \"1651363200\": 14723000,\n        \"1609459200\": 11565019,\n        \"1577836800\": 9193266,\n        \"1546300800\": 6988614 // Jan 1, 2019\n    },\n    // Sample addresses for demo\n    sampleHolders: [\n        \"0x7Be8076f4EA4A4AD08075C2508e481d6C946D12b\",\n        \"0xb88F61E6FbdA83fbfffAbE364112137480398018\",\n        \"0x0315FA3813Ff4999C264641B202d0D2B21df139C\",\n        \"0xA858DDc0445d8131daC4d1DE01f834ffcbA52Ef1\",\n        \"0x1b523DC1cB8B17B0170aa9234cA1CFF3E1Ea36bF\"\n    ]\n};\n// Provider and multicall contract initialization\nlet provider = null;\nlet multicallContract = null;\n/**\n * Initialize provider with Alchemy only\n */ const initProvider = ()=>{\n    if (provider) return provider;\n    console.log(\"Initializing provider...\");\n    if (ALCHEMY_API_KEY) {\n        try {\n            console.log(\"Using Alchemy provider\");\n            provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.ethers.providers.StaticJsonRpcProvider(ALCHEMY_API_URL);\n            return provider;\n        } catch (error) {\n            console.error(\"Failed to create Alchemy provider:\", error.message);\n            provider = null;\n        }\n    } else {\n        console.error(\"No Alchemy API key provided!\");\n    }\n    console.log(\"Using static provider as last resort\");\n    provider = STATIC_PROVIDER;\n    return provider;\n};\n/**\n * Initialize Multicall contract\n */ const initMulticall = ()=>{\n    if (multicallContract) return multicallContract;\n    const p = provider || initProvider();\n    if (!p) {\n        console.error(\"Failed to initialize provider for multicall contract\");\n        return null;\n    }\n    try {\n        multicallContract = new ethers__WEBPACK_IMPORTED_MODULE_0__.ethers.Contract(MULTICALL_ADDRESS, MULTICALL_ABI, p);\n        console.log(\"Multicall contract initialized\");\n        return multicallContract;\n    } catch (error) {\n        console.error(\"Failed to initialize multicall contract:\", error.message);\n        return null;\n    }\n};\n// Initialize provider and multicall contract\nprovider = initProvider();\nmulticallContract = initMulticall();\n/**\n * Check if we have fallback data for this timestamp\n */ function hasFallbackData(timestamp) {\n    return timestamp in FALLBACK_DEMO_DATA.blocks || Object.keys(FALLBACK_DEMO_DATA.blocks).some((t)=>Math.abs(parseInt(t) - timestamp) < 86400);\n}\n/**\n * Get closest fallback block number\n */ function getFallbackBlockNumber(timestamp) {\n    if (timestamp in FALLBACK_DEMO_DATA.blocks) {\n        return FALLBACK_DEMO_DATA.blocks[timestamp];\n    }\n    const timestamps = Object.keys(FALLBACK_DEMO_DATA.blocks).map(Number);\n    let closest = timestamps[0];\n    let minDiff = Math.abs(closest - timestamp);\n    for(let i = 1; i < timestamps.length; i++){\n        const diff = Math.abs(timestamps[i] - timestamp);\n        if (diff < minDiff) {\n            minDiff = diff;\n            closest = timestamps[i];\n        }\n    }\n    return FALLBACK_DEMO_DATA.blocks[closest];\n}\n/**\n * Find block number at specific timestamp using binary search\n */ async function getBlockNumberAtTimestamp(timestamp) {\n    try {\n        // Binary search implementation\n        let low = 0;\n        let high = await provider.getBlockNumber();\n        let result = high;\n        console.log(`Finding block at or after timestamp ${timestamp} using binary search...`);\n        while(low <= high){\n            const mid = Math.floor((low + high) / 2);\n            const block = await provider.getBlock(mid);\n            if (!block) break;\n            if (block.timestamp < timestamp) {\n                low = mid + 1;\n            } else {\n                result = mid;\n                high = mid - 1;\n            }\n        }\n        console.log(`Found block #${result} for timestamp ${timestamp}`);\n        return result;\n    } catch (error) {\n        console.error(\"Error in binary search for block:\", error);\n        // Fallback to Etherscan API\n        try {\n            console.log(\"Falling back to Etherscan API for block number...\");\n            const response = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(ETHERSCAN_API_URL, {\n                params: {\n                    module: \"block\",\n                    action: \"getblocknobytime\",\n                    timestamp,\n                    closest: \"before\",\n                    apikey: ETHERSCAN_API_KEY\n                }\n            });\n            if (response.data.status !== \"1\") {\n                throw new Error(`Etherscan API error: ${response.data.message}`);\n            }\n            return parseInt(response.data.result);\n        } catch (secondaryError) {\n            console.error(\"Etherscan fallback failed:\", secondaryError);\n            // Use fallback data if available\n            if (hasFallbackData(timestamp)) {\n                console.log(`Using fallback block data for timestamp ${timestamp}`);\n                return getFallbackBlockNumber(timestamp);\n            }\n            throw error;\n        }\n    }\n}\n/**\n * Get BAYC holders at a specific block by cursor-paging through tokens → owner\n */ async function getBAYCHoldersAtBlock(blockNumber) {\n    try {\n        console.log(`Querying The Graph for BAYC holders at block ${blockNumber}…`);\n        const PAGE_SIZE = 1000;\n        let lastId = \"\"; // cursor: start before the first token\n        const holders = new Set();\n        const QUERY = `\n      query holders($block: Int!, $lastId: String!) {\n        tokens(\n          first: ${PAGE_SIZE},\n          where: { id_gt: $lastId },\n          block: { number: $block },\n          orderBy: id,\n          orderDirection: asc\n        ) {\n          id\n          owner { id }\n        }\n      }\n    `;\n        while(true){\n            console.log(`Fetching tokens after id='${lastId}'…`);\n            const response = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(GRAPH_URL, {\n                query: QUERY,\n                variables: {\n                    block: blockNumber,\n                    lastId\n                }\n            });\n            if (response.data.errors) {\n                console.error(\"GraphQL errors:\", response.data.errors);\n                throw new Error(\"GraphQL query failed\");\n            }\n            const tokens = response.data.data.tokens;\n            if (!tokens.length) {\n                console.log(\"No more tokens to fetch\");\n                break;\n            }\n            // Add each owner to our Set\n            tokens.forEach((t)=>holders.add(t.owner.id.toLowerCase()));\n            // Advance cursor to the last token ID of this page\n            lastId = tokens[tokens.length - 1].id;\n            console.log(`  → Fetched ${tokens.length} tokens; unique owners so far: ${holders.size}`);\n        }\n        console.log(`Found ${holders.size} total unique BAYC holders`);\n        return Array.from(holders);\n    } catch (error) {\n        console.error(\"Error fetching BAYC holders via subgraph:\", error);\n        // fallback to transfer-history method\n        return getHoldersFromTokenTransfers(blockNumber);\n    }\n}\n/**\n * Fallback method to get holders from token transfers\n */ async function getHoldersFromTokenTransfers(blockNumber) {\n    try {\n        console.log(\"Falling back to token transfers method\");\n        // Track ownership using transfer history\n        const ownershipMap = new Map();\n        let page = 1;\n        let hasMoreData = true;\n        while(hasMoreData && page <= 5){\n            // Fetch token transfers from Etherscan\n            const response = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(ETHERSCAN_API_URL, {\n                params: {\n                    module: \"account\",\n                    action: \"tokennfttx\",\n                    contractaddress: BAYC_CONTRACT_ADDRESS,\n                    page,\n                    offset: 100,\n                    sort: \"asc\",\n                    apikey: ETHERSCAN_API_KEY\n                }\n            });\n            if (response.data.status !== \"1\") {\n                console.error(`Etherscan API error: ${response.data.message}`);\n                break;\n            }\n            const transfers = response.data.result;\n            console.log(`Retrieved ${transfers.length} transfers (page ${page})`);\n            if (transfers.length === 0) {\n                hasMoreData = false;\n                break;\n            }\n            // Process transfers\n            for (const transfer of transfers){\n                // Skip transfers after our target block\n                if (parseInt(transfer.blockNumber) > blockNumber) {\n                    hasMoreData = false;\n                    break;\n                }\n                const tokenId = transfer.tokenID;\n                const from = transfer.from.toLowerCase();\n                const to = transfer.to.toLowerCase();\n                // Skip token minting (from zero address)\n                if (from !== \"0x0000000000000000000000000000000000000000\") {\n                    // Remove token from previous owner\n                    if (ownershipMap.has(from)) {\n                        ownershipMap.get(from).delete(tokenId);\n                        // If the owner has no more tokens, remove them from the map\n                        if (ownershipMap.get(from).size === 0) {\n                            ownershipMap.delete(from);\n                        }\n                    }\n                }\n                // Add token to new owner\n                if (!ownershipMap.has(to)) {\n                    ownershipMap.set(to, new Set());\n                }\n                ownershipMap.get(to).add(tokenId);\n            }\n            page++;\n        }\n        // Extract holders at this block\n        const holders = Array.from(ownershipMap.keys()).filter((address)=>address !== \"0x0000000000000000000000000000000000000000\");\n        console.log(`Found ${holders.length} BAYC holders from historical transfers`);\n        return holders;\n    } catch (error) {\n        console.error(\"Error with token transfers method:\", error);\n        return FALLBACK_DEMO_DATA.sampleHolders;\n    }\n}\n/**\n * Get ETH balances for multiple addresses in a single multicall\n * This is the key optimization of this implementation\n */ async function getEthBalancesMulticall(addresses, blockNumber) {\n    if (!multicallContract) {\n        multicallContract = initMulticall();\n        if (!multicallContract) {\n            throw new Error(\"Failed to initialize multicall contract\");\n        }\n    }\n    try {\n        console.log(`Getting ETH balances for ${addresses.length} addresses with Multicall...`);\n        // Break addresses into chunks of 500 to avoid gas limit issues\n        const chunkSize = 500;\n        const balances = [];\n        for(let i = 0; i < addresses.length; i += chunkSize){\n            const chunk = addresses.slice(i, i + chunkSize);\n            console.log(`Processing chunk ${Math.floor(i / chunkSize) + 1}/${Math.ceil(addresses.length / chunkSize)} (${chunk.length} addresses)`);\n            // Create calls array for multicall\n            const calls = chunk.map((address)=>({\n                    target: MULTICALL_ADDRESS,\n                    allowFailure: true,\n                    callData: multicallContract.interface.encodeFunctionData(\"getEthBalance\", [\n                        address\n                    ])\n                }));\n            // Execute multicall\n            const results = await multicallContract.aggregate3(calls, {\n                blockTag: blockNumber\n            });\n            // Process results\n            for(let j = 0; j < results.length; j++){\n                const result = results[j];\n                if (result.success) {\n                    try {\n                        const balance = ethers__WEBPACK_IMPORTED_MODULE_0__.ethers.utils.defaultAbiCoder.decode([\n                            \"uint256\"\n                        ], result.returnData)[0];\n                        balances.push(balance);\n                    } catch (error) {\n                        console.error(`Error decoding balance result for address ${chunk[j]}:`, error.message);\n                        balances.push(ethers__WEBPACK_IMPORTED_MODULE_0__.ethers.BigNumber.from(0));\n                    }\n                } else {\n                    console.warn(`Failed to get balance for address ${chunk[j]}`);\n                    balances.push(ethers__WEBPACK_IMPORTED_MODULE_0__.ethers.BigNumber.from(0));\n                }\n            }\n        }\n        return balances;\n    } catch (error) {\n        console.error(\"Error in multicall getEthBalances:\", error);\n        // Fallback to regular balance fetching if multicall fails\n        console.log(\"Multicall failed, falling back to individual balance queries...\");\n        return getFallbackBalances(addresses, blockNumber);\n    }\n}\n/**\n * Fallback method to get balances individually if multicall fails\n */ async function getFallbackBalances(addresses, blockNumber) {\n    console.log(`Getting balances individually for ${addresses.length} addresses...`);\n    const balances = [];\n    const batchSize = 10; // Process in small batches\n    for(let i = 0; i < addresses.length; i += batchSize){\n        const batch = addresses.slice(i, i + batchSize);\n        // Process batch concurrently\n        const batchResults = await Promise.all(batch.map(async (address)=>{\n            try {\n                return await provider.getBalance(address, blockNumber);\n            } catch (error) {\n                console.error(`Error getting balance for ${address}:`, error.message);\n                return ethers__WEBPACK_IMPORTED_MODULE_0__.ethers.BigNumber.from(0);\n            }\n        }));\n        balances.push(...batchResults);\n        if (i % 50 === 0 && i > 0) {\n            console.log(`Processed ${i}/${addresses.length} addresses...`);\n        }\n    }\n    return balances;\n}\n/**\n * Save results to file for persistence\n */ async function saveResultsToFile(implementationId, timestamp, result) {\n    try {\n        // Create directory if it doesn't exist\n        const dir = path__WEBPACK_IMPORTED_MODULE_3___default().dirname(RESULTS_FILE_PATH);\n        if (!fs__WEBPACK_IMPORTED_MODULE_2___default().existsSync(dir)) {\n            fs__WEBPACK_IMPORTED_MODULE_2___default().mkdirSync(dir, {\n                recursive: true\n            });\n        }\n        // Read existing results or create new object\n        let results = {};\n        if (fs__WEBPACK_IMPORTED_MODULE_2___default().existsSync(RESULTS_FILE_PATH)) {\n            const fileContent = fs__WEBPACK_IMPORTED_MODULE_2___default().readFileSync(RESULTS_FILE_PATH, \"utf8\");\n            results = JSON.parse(fileContent);\n        }\n        // Add new result\n        if (!results[implementationId]) {\n            results[implementationId] = {};\n        }\n        // Convert BigNumber to string for JSON storage\n        const resultToSave = {\n            ...result,\n            totalWei: result.totalWei.toString(),\n            executionTime: result.executionTime,\n            timestamp: new Date().toISOString()\n        };\n        results[implementationId][timestamp] = resultToSave;\n        // Write back to file\n        fs__WEBPACK_IMPORTED_MODULE_2___default().writeFileSync(RESULTS_FILE_PATH, JSON.stringify(results, null, 2));\n        console.log(`Results saved to ${RESULTS_FILE_PATH}`);\n    } catch (error) {\n        console.error(\"Error saving results to file:\", error);\n    }\n}\n/**\n * Get previous results from cache file\n */ function getPreviousResults() {\n    try {\n        if (fs__WEBPACK_IMPORTED_MODULE_2___default().existsSync(RESULTS_FILE_PATH)) {\n            const fileContent = fs__WEBPACK_IMPORTED_MODULE_2___default().readFileSync(RESULTS_FILE_PATH, \"utf8\");\n            return JSON.parse(fileContent);\n        }\n    } catch (error) {\n        console.error(\"Error reading previous results:\", error);\n    }\n    return {};\n}\n/**\n * Get total ETH value of all BAYC holders\n */ async function getTotalEthValueOfHolders(timestamp) {\n    const startTime = Date.now();\n    try {\n        // Step 1: Get block number at timestamp\n        const blockNumber = await getBlockNumberAtTimestamp(timestamp);\n        console.log(`Using block number ${blockNumber} for timestamp ${timestamp}`);\n        // Step 2: Get BAYC holders at that block\n        const holders = await getBAYCHoldersAtBlock(blockNumber);\n        console.log(`Found ${holders.length} BAYC holders at this block`);\n        // Step 3: Get ETH balances of all holders\n        const balances = await getEthBalancesMulticall(holders, blockNumber);\n        console.log(`Retrieved ${balances.length} balances`);\n        if (balances.length !== holders.length) {\n            console.warn(`Warning: Number of balances (${balances.length}) doesn't match holders (${holders.length})`);\n        }\n        // Step 4: Sum total ETH value\n        const totalWei = balances.reduce((sum, balance)=>sum.add(balance), ethers__WEBPACK_IMPORTED_MODULE_0__.ethers.BigNumber.from(0));\n        const totalEth = ethers__WEBPACK_IMPORTED_MODULE_0__.ethers.utils.formatEther(totalWei);\n        const executionTime = Date.now() - startTime;\n        console.log(`Total ETH value: ${totalEth} ETH (execution time: ${executionTime}ms)`);\n        const result = {\n            blockNumber,\n            holderCount: holders.length,\n            totalWei,\n            totalEth,\n            executionTime,\n            method: \"The Graph\",\n            implementation: \"multicall\"\n        };\n        // Save results for persistence\n        await saveResultsToFile(\"multicall\", timestamp, result);\n        return result;\n    } catch (error) {\n        console.error(\"Error calculating total ETH value:\", error);\n        const executionTime = Date.now() - startTime;\n        return {\n            error: error.message,\n            blockNumber: 0,\n            holderCount: 0,\n            totalWei: ethers__WEBPACK_IMPORTED_MODULE_0__.ethers.BigNumber.from(0),\n            totalEth: \"0\",\n            executionTime,\n            method: \"The Graph (errored)\",\n            implementation: \"multicall\"\n        };\n    }\n}\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            message: \"Method not allowed\"\n        });\n    }\n    try {\n        const { timestamp } = req.body;\n        if (!timestamp) {\n            return res.status(400).json({\n                message: \"Timestamp is required\"\n            });\n        }\n        // Check if we have cached results\n        const previousResults = getPreviousResults();\n        const cachedResult = previousResults?.[\"multicall\"]?.[timestamp];\n        if (cachedResult && req.body.useCache !== false) {\n            console.log(`Using cached result for timestamp ${timestamp}`);\n            // Convert string back to BigNumber for consistency\n            cachedResult.totalWei = ethers__WEBPACK_IMPORTED_MODULE_0__.ethers.BigNumber.from(cachedResult.totalWei);\n            return res.status(200).json({\n                ...cachedResult,\n                fromCache: true\n            });\n        }\n        const result = await getTotalEthValueOfHolders(timestamp);\n        return res.status(200).json(result);\n    } catch (error) {\n        console.error(\"Error in multicall API handler:\", error);\n        return res.status(500).json({\n            message: \"Error processing request\",\n            error: error.message\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9wYWdlcy9hcGkvaW1wbGVtZW50YXRpb25zL211bHRpY2FsbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBLGdGQUFnRjtBQUNoRDtBQUNOO0FBQ047QUFDSTtBQUV4QixZQUFZO0FBQ1osTUFBTUksd0JBQXdCO0FBQzlCLE1BQU1DLG9CQUFvQjtBQUMxQixNQUFNQyxvQkFBb0JDLFFBQVFDLEdBQUcsQ0FBQ0YsaUJBQWlCLElBQUk7QUFDM0QsTUFBTUcsa0JBQWtCRixRQUFRQyxHQUFHLENBQUNDLGVBQWUsSUFBSTtBQUN2RCxNQUFNQyxrQkFBa0IsQ0FBQyxxQ0FBcUMsRUFBRUQsZ0JBQWdCLENBQUM7QUFFakYsK0JBQStCO0FBQy9CLE1BQU1FLG9CQUFvQiw4Q0FBOEMsc0JBQXNCO0FBRTlGLHFCQUFxQjtBQUNyQixNQUFNQyxnQkFBZ0I7SUFDcEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsbUNBQW1DO0FBQ25DLE1BQU1DLFlBQVlOLFFBQVFDLEdBQUcsQ0FBQ00saUJBQWlCO0FBRS9DLHVDQUF1QztBQUN2QyxNQUFNQyxrQkFBa0IsSUFBSWYsMENBQU1BLENBQUNnQixTQUFTLENBQUNDLHFCQUFxQixDQUFDUDtBQUVuRSw2Q0FBNkM7QUFDN0MsTUFBTVEsb0JBQW9CZixnREFBUyxDQUFDSSxRQUFRYSxHQUFHLElBQUksUUFBUTtBQUUzRCxrRUFBa0U7QUFFbEUsZ0RBQWdEO0FBQ2hELE1BQU1DLHFCQUFxQjtJQUN6QixxQ0FBcUM7SUFDckNDLFFBQVE7UUFDTixjQUFjO1FBQ2QsY0FBYztRQUNkLGNBQWM7UUFDZCxjQUFjLFFBQVUsY0FBYztJQUN4QztJQUNBLDRCQUE0QjtJQUM1QkMsZUFBZTtRQUNiO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtBQUNIO0FBRUEsaURBQWlEO0FBQ2pELElBQUlDLFdBQVc7QUFDZixJQUFJQyxvQkFB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cy9hcGkvaW1wbGVtZW50YXRpb25zL211bHRpY2FsbC5qcz8yYWY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIE11bHRpY2FsbCBpbXBsZW1lbnRhdGlvbiAtIGJhdGNoZXMgRVRIIGJhbGFuY2UgcXVlcmllcyBmb3IgbWF4aW11bSBlZmZpY2llbmN5XG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuLy8gQ29uc3RhbnRzXG5jb25zdCBCQVlDX0NPTlRSQUNUX0FERFJFU1MgPSAnMHhCQzRDQTBFZEE3NjQ3QThhQjdDMjA2MWMyRTExOEExOGE5MzZmMTNEJztcbmNvbnN0IEVUSEVSU0NBTl9BUElfVVJMID0gJ2h0dHBzOi8vYXBpLmV0aGVyc2Nhbi5pby9hcGknO1xuY29uc3QgRVRIRVJTQ0FOX0FQSV9LRVkgPSBwcm9jZXNzLmVudi5FVEhFUlNDQU5fQVBJX0tFWSB8fCAnJztcbmNvbnN0IEFMQ0hFTVlfQVBJX0tFWSA9IHByb2Nlc3MuZW52LkFMQ0hFTVlfQVBJX0tFWSB8fCAnJztcbmNvbnN0IEFMQ0hFTVlfQVBJX1VSTCA9IGBodHRwczovL2V0aC1tYWlubmV0LmcuYWxjaGVteS5jb20vdjIvJHtBTENIRU1ZX0FQSV9LRVl9YDtcblxuLy8gTXVsdGljYWxsIENvbnRyYWN0IEFkZHJlc3Nlc1xuY29uc3QgTVVMVElDQUxMX0FERFJFU1MgPSAnMHhjQTExYmRlMDU5NzdiMzYzMTE2NzAyODg2MmJFMmExNzM5NzZDQTExJzsgLy8gTXVsdGljYWxsMyBjb250cmFjdFxuXG4vLyBBQkkgZm9yIE11bHRpY2FsbDNcbmNvbnN0IE1VTFRJQ0FMTF9BQkkgPSBbXG4gICdmdW5jdGlvbiBhZ2dyZWdhdGUodHVwbGUoYWRkcmVzcyB0YXJnZXQsIGJ5dGVzIGNhbGxEYXRhKVtdIGNhbGxzKSB2aWV3IHJldHVybnMgKHVpbnQyNTYgYmxvY2tOdW1iZXIsIGJ5dGVzW10gcmV0dXJuRGF0YSknLFxuICAnZnVuY3Rpb24gYmxvY2tBbmRBZ2dyZWdhdGUodHVwbGUoYWRkcmVzcyB0YXJnZXQsIGJ5dGVzIGNhbGxEYXRhKVtdIGNhbGxzKSB2aWV3IHJldHVybnMgKHVpbnQyNTYgYmxvY2tOdW1iZXIsIGJ5dGVzMzIgYmxvY2tIYXNoLCB0dXBsZShib29sIHN1Y2Nlc3MsIGJ5dGVzIHJldHVybkRhdGEpW10gcmV0dXJuRGF0YSknLFxuICAnZnVuY3Rpb24gZ2V0QmxvY2tIYXNoKHVpbnQyNTYgYmxvY2tOdW1iZXIpIHZpZXcgcmV0dXJucyAoYnl0ZXMzMiBibG9ja0hhc2gpJyxcbiAgJ2Z1bmN0aW9uIGdldEJsb2NrTnVtYmVyKCkgdmlldyByZXR1cm5zICh1aW50MjU2IGJsb2NrTnVtYmVyKScsXG4gICdmdW5jdGlvbiBnZXRDdXJyZW50QmxvY2tDb2luYmFzZSgpIHZpZXcgcmV0dXJucyAoYWRkcmVzcyBjb2luYmFzZSknLFxuICAnZnVuY3Rpb24gZ2V0Q3VycmVudEJsb2NrRGlmZmljdWx0eSgpIHZpZXcgcmV0dXJucyAodWludDI1NiBkaWZmaWN1bHR5KScsXG4gICdmdW5jdGlvbiBnZXRDdXJyZW50QmxvY2tHYXNMaW1pdCgpIHZpZXcgcmV0dXJucyAodWludDI1NiBnYXNsaW1pdCknLFxuICAnZnVuY3Rpb24gZ2V0Q3VycmVudEJsb2NrVGltZXN0YW1wKCkgdmlldyByZXR1cm5zICh1aW50MjU2IHRpbWVzdGFtcCknLFxuICAnZnVuY3Rpb24gZ2V0RXRoQmFsYW5jZShhZGRyZXNzIGFkZHIpIHZpZXcgcmV0dXJucyAodWludDI1NiBiYWxhbmNlKScsXG4gICdmdW5jdGlvbiBnZXRMYXN0QmxvY2tIYXNoKCkgdmlldyByZXR1cm5zIChieXRlczMyIGJsb2NrSGFzaCknLFxuICAnZnVuY3Rpb24gYWdncmVnYXRlMyh0dXBsZShhZGRyZXNzIHRhcmdldCwgYm9vbCBhbGxvd0ZhaWx1cmUsIGJ5dGVzIGNhbGxEYXRhKVtdIGNhbGxzKSB2aWV3IHJldHVybnMgKHR1cGxlKGJvb2wgc3VjY2VzcywgYnl0ZXMgcmV0dXJuRGF0YSlbXSByZXR1cm5EYXRhKScsXG4gICdmdW5jdGlvbiBhZ2dyZWdhdGUzVmFsdWUodHVwbGUoYWRkcmVzcyB0YXJnZXQsIGJvb2wgYWxsb3dGYWlsdXJlLCBieXRlcyBjYWxsRGF0YSwgdWludDI1NiB2YWx1ZSlbXSBjYWxscykgcGF5YWJsZSByZXR1cm5zICh0dXBsZShib29sIHN1Y2Nlc3MsIGJ5dGVzIHJldHVybkRhdGEpW10gcmV0dXJuRGF0YSknLFxuICAnZnVuY3Rpb24gdHJ5QWdncmVnYXRlKGJvb2wgcmVxdWlyZVN1Y2Nlc3MsIHR1cGxlKGFkZHJlc3MgdGFyZ2V0LCBieXRlcyBjYWxsRGF0YSlbXSBjYWxscykgdmlldyByZXR1cm5zICh0dXBsZShib29sIHN1Y2Nlc3MsIGJ5dGVzIHJldHVybkRhdGEpW10gcmV0dXJuRGF0YSknLFxuICAnZnVuY3Rpb24gdHJ5QmxvY2tBbmRBZ2dyZWdhdGUoYm9vbCByZXF1aXJlU3VjY2VzcywgdHVwbGUoYWRkcmVzcyB0YXJnZXQsIGJ5dGVzIGNhbGxEYXRhKVtdIGNhbGxzKSB2aWV3IHJldHVybnMgKHVpbnQyNTYgYmxvY2tOdW1iZXIsIGJ5dGVzMzIgYmxvY2tIYXNoLCB0dXBsZShib29sIHN1Y2Nlc3MsIGJ5dGVzIHJldHVybkRhdGEpW10gcmV0dXJuRGF0YSknXG5dO1xuXG4vLyBHcmFwaCBBUEkgZW5kcG9pbnQgZm9yIEJBWUMgZGF0YVxuY29uc3QgR1JBUEhfVVJMID0gcHJvY2Vzcy5lbnYuQkFZQ19TVUJHUkFQSF9VUkw7XG5cbi8vIFN0YXRpYyBwcm92aWRlciBhcyByZWxpYWJsZSBmYWxsYmFja1xuY29uc3QgU1RBVElDX1BST1ZJREVSID0gbmV3IGV0aGVycy5wcm92aWRlcnMuU3RhdGljSnNvblJwY1Byb3ZpZGVyKEFMQ0hFTVlfQVBJX1VSTCk7XG5cbi8vIFJlc3VsdHMgc3RvcmFnZSAtIHBlcnNpc3QgYmV0d2VlbiByZXN0YXJ0c1xuY29uc3QgUkVTVUxUU19GSUxFX1BBVEggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2RhdGEnLCAncmVzdWx0cy5qc29uJyk7XG5cbi8vIFJlbW92ZWQgcHVibGljIFJQQyBlbmRwb2ludHMgc2luY2Ugd2UncmUgb25seSB1c2luZyBBbGNoZW15IG5vd1xuXG4vLyBGYWxsYmFjayBkYXRhIGZvciB3aGVuIG5ldHdvcmsgaXMgdW5hdmFpbGFibGVcbmNvbnN0IEZBTExCQUNLX0RFTU9fREFUQSA9IHtcbiAgLy8gRXhhbXBsZSB0aW1lc3RhbXAgLT4gYmxvY2sgbWFwcGluZ1xuICBibG9ja3M6IHtcbiAgICAnMTY1MTM2MzIwMCc6IDE0NzIzMDAwLCAvLyBNYXkgMSwgMjAyMlxuICAgICcxNjA5NDU5MjAwJzogMTE1NjUwMTksIC8vIEphbiAxLCAyMDIxXG4gICAgJzE1Nzc4MzY4MDAnOiA5MTkzMjY2LCAgLy8gSmFuIDEsIDIwMjBcbiAgICAnMTU0NjMwMDgwMCc6IDY5ODg2MTQgICAvLyBKYW4gMSwgMjAxOVxuICB9LFxuICAvLyBTYW1wbGUgYWRkcmVzc2VzIGZvciBkZW1vXG4gIHNhbXBsZUhvbGRlcnM6IFtcbiAgICAnMHg3QmU4MDc2ZjRFQTRBNEFEMDgwNzVDMjUwOGU0ODFkNkM5NDZEMTJiJywgLy8gT3BlblNlYVxuICAgICcweGI4OEY2MUU2RmJkQTgzZmJmZmZBYkUzNjQxMTIxMzc0ODAzOTgwMTgnLFxuICAgICcweDAzMTVGQTM4MTNGZjQ5OTlDMjY0NjQxQjIwMmQwRDJCMjFkZjEzOUMnLFxuICAgICcweEE4NThERGMwNDQ1ZDgxMzFkYUM0ZDFERTAxZjgzNGZmY2JBNTJFZjEnLFxuICAgICcweDFiNTIzREMxY0I4QjE3QjAxNzBhYTkyMzRjQTFDRkYzRTFFYTM2YkYnXG4gIF1cbn07XG5cbi8vIFByb3ZpZGVyIGFuZCBtdWx0aWNhbGwgY29udHJhY3QgaW5pdGlhbGl6YXRpb25cbmxldCBwcm92aWRlciA9IG51bGw7XG5sZXQgbXVsdGljYWxsQ29udHJhY3QgPSBudWxsO1xuXG4vKipcbiAqIEluaXRpYWxpemUgcHJvdmlkZXIgd2l0aCBBbGNoZW15IG9ubHlcbiAqL1xuY29uc3QgaW5pdFByb3ZpZGVyID0gKCkgPT4ge1xuICBpZiAocHJvdmlkZXIpIHJldHVybiBwcm92aWRlcjtcbiAgXG4gIGNvbnNvbGUubG9nKFwiSW5pdGlhbGl6aW5nIHByb3ZpZGVyLi4uXCIpO1xuICBcbiAgaWYgKEFMQ0hFTVlfQVBJX0tFWSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIEFsY2hlbXkgcHJvdmlkZXJcIik7XG4gICAgICBwcm92aWRlciA9IG5ldyBldGhlcnMucHJvdmlkZXJzLlN0YXRpY0pzb25ScGNQcm92aWRlcihBTENIRU1ZX0FQSV9VUkwpO1xuICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIEFsY2hlbXkgcHJvdmlkZXI6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICBwcm92aWRlciA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJObyBBbGNoZW15IEFQSSBrZXkgcHJvdmlkZWQhXCIpO1xuICB9XG4gIFxuICBjb25zb2xlLmxvZyhcIlVzaW5nIHN0YXRpYyBwcm92aWRlciBhcyBsYXN0IHJlc29ydFwiKTtcbiAgcHJvdmlkZXIgPSBTVEFUSUNfUFJPVklERVI7XG4gIHJldHVybiBwcm92aWRlcjtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBNdWx0aWNhbGwgY29udHJhY3RcbiAqL1xuY29uc3QgaW5pdE11bHRpY2FsbCA9ICgpID0+IHtcbiAgaWYgKG11bHRpY2FsbENvbnRyYWN0KSByZXR1cm4gbXVsdGljYWxsQ29udHJhY3Q7XG4gIFxuICBjb25zdCBwID0gcHJvdmlkZXIgfHwgaW5pdFByb3ZpZGVyKCk7XG4gIGlmICghcCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBwcm92aWRlciBmb3IgbXVsdGljYWxsIGNvbnRyYWN0XCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIFxuICB0cnkge1xuICAgIG11bHRpY2FsbENvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChNVUxUSUNBTExfQUREUkVTUywgTVVMVElDQUxMX0FCSSwgcCk7XG4gICAgY29uc29sZS5sb2coXCJNdWx0aWNhbGwgY29udHJhY3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgcmV0dXJuIG11bHRpY2FsbENvbnRyYWN0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBtdWx0aWNhbGwgY29udHJhY3Q6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vLyBJbml0aWFsaXplIHByb3ZpZGVyIGFuZCBtdWx0aWNhbGwgY29udHJhY3RcbnByb3ZpZGVyID0gaW5pdFByb3ZpZGVyKCk7XG5tdWx0aWNhbGxDb250cmFjdCA9IGluaXRNdWx0aWNhbGwoKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBoYXZlIGZhbGxiYWNrIGRhdGEgZm9yIHRoaXMgdGltZXN0YW1wXG4gKi9cbmZ1bmN0aW9uIGhhc0ZhbGxiYWNrRGF0YSh0aW1lc3RhbXApIHtcbiAgcmV0dXJuIHRpbWVzdGFtcCBpbiBGQUxMQkFDS19ERU1PX0RBVEEuYmxvY2tzIHx8IFxuICAgICAgICBPYmplY3Qua2V5cyhGQUxMQkFDS19ERU1PX0RBVEEuYmxvY2tzKS5zb21lKHQgPT4gTWF0aC5hYnMocGFyc2VJbnQodCkgLSB0aW1lc3RhbXApIDwgODY0MDApO1xufVxuXG4vKipcbiAqIEdldCBjbG9zZXN0IGZhbGxiYWNrIGJsb2NrIG51bWJlclxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0Jsb2NrTnVtYmVyKHRpbWVzdGFtcCkge1xuICBpZiAodGltZXN0YW1wIGluIEZBTExCQUNLX0RFTU9fREFUQS5ibG9ja3MpIHtcbiAgICByZXR1cm4gRkFMTEJBQ0tfREVNT19EQVRBLmJsb2Nrc1t0aW1lc3RhbXBdO1xuICB9XG4gIFxuICBjb25zdCB0aW1lc3RhbXBzID0gT2JqZWN0LmtleXMoRkFMTEJBQ0tfREVNT19EQVRBLmJsb2NrcykubWFwKE51bWJlcik7XG4gIGxldCBjbG9zZXN0ID0gdGltZXN0YW1wc1swXTtcbiAgbGV0IG1pbkRpZmYgPSBNYXRoLmFicyhjbG9zZXN0IC0gdGltZXN0YW1wKTtcbiAgXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdGltZXN0YW1wcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyh0aW1lc3RhbXBzW2ldIC0gdGltZXN0YW1wKTtcbiAgICBpZiAoZGlmZiA8IG1pbkRpZmYpIHtcbiAgICAgIG1pbkRpZmYgPSBkaWZmO1xuICAgICAgY2xvc2VzdCA9IHRpbWVzdGFtcHNbaV07XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gRkFMTEJBQ0tfREVNT19EQVRBLmJsb2Nrc1tjbG9zZXN0XTtcbn1cblxuLyoqXG4gKiBGaW5kIGJsb2NrIG51bWJlciBhdCBzcGVjaWZpYyB0aW1lc3RhbXAgdXNpbmcgYmluYXJ5IHNlYXJjaFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRCbG9ja051bWJlckF0VGltZXN0YW1wKHRpbWVzdGFtcCkge1xuICB0cnkge1xuICAgIC8vIEJpbmFyeSBzZWFyY2ggaW1wbGVtZW50YXRpb25cbiAgICBsZXQgbG93ID0gMDtcbiAgICBsZXQgaGlnaCA9IGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrTnVtYmVyKCk7XG4gICAgbGV0IHJlc3VsdCA9IGhpZ2g7XG5cbiAgICBjb25zb2xlLmxvZyhgRmluZGluZyBibG9jayBhdCBvciBhZnRlciB0aW1lc3RhbXAgJHt0aW1lc3RhbXB9IHVzaW5nIGJpbmFyeSBzZWFyY2guLi5gKTtcbiAgICBcbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBjb25zdCBibG9jayA9IGF3YWl0IHByb3ZpZGVyLmdldEJsb2NrKG1pZCk7XG4gICAgICBpZiAoIWJsb2NrKSBicmVhaztcblxuICAgICAgaWYgKGJsb2NrLnRpbWVzdGFtcCA8IHRpbWVzdGFtcCkge1xuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gbWlkO1xuICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgRm91bmQgYmxvY2sgIyR7cmVzdWx0fSBmb3IgdGltZXN0YW1wICR7dGltZXN0YW1wfWApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gYmluYXJ5IHNlYXJjaCBmb3IgYmxvY2s6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRvIEV0aGVyc2NhbiBBUElcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0ZhbGxpbmcgYmFjayB0byBFdGhlcnNjYW4gQVBJIGZvciBibG9jayBudW1iZXIuLi4nKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KEVUSEVSU0NBTl9BUElfVVJMLCB7XG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIG1vZHVsZTogJ2Jsb2NrJyxcbiAgICAgICAgICBhY3Rpb246ICdnZXRibG9ja25vYnl0aW1lJyxcbiAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgY2xvc2VzdDogJ2JlZm9yZScsXG4gICAgICAgICAgYXBpa2V5OiBFVEhFUlNDQU5fQVBJX0tFWVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuc3RhdHVzICE9PSAnMScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdGhlcnNjYW4gQVBJIGVycm9yOiAke3Jlc3BvbnNlLmRhdGEubWVzc2FnZX1gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlSW50KHJlc3BvbnNlLmRhdGEucmVzdWx0KTtcbiAgICB9IGNhdGNoIChzZWNvbmRhcnlFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXRoZXJzY2FuIGZhbGxiYWNrIGZhaWxlZDonLCBzZWNvbmRhcnlFcnJvcik7XG4gICAgICBcbiAgICAgIC8vIFVzZSBmYWxsYmFjayBkYXRhIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKGhhc0ZhbGxiYWNrRGF0YSh0aW1lc3RhbXApKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBVc2luZyBmYWxsYmFjayBibG9jayBkYXRhIGZvciB0aW1lc3RhbXAgJHt0aW1lc3RhbXB9YCk7XG4gICAgICAgIHJldHVybiBnZXRGYWxsYmFja0Jsb2NrTnVtYmVyKHRpbWVzdGFtcCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCBCQVlDIGhvbGRlcnMgYXQgYSBzcGVjaWZpYyBibG9jayBieSBjdXJzb3ItcGFnaW5nIHRocm91Z2ggdG9rZW5zIOKGkiBvd25lclxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRCQVlDSG9sZGVyc0F0QmxvY2soYmxvY2tOdW1iZXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgUXVlcnlpbmcgVGhlIEdyYXBoIGZvciBCQVlDIGhvbGRlcnMgYXQgYmxvY2sgJHtibG9ja051bWJlcn3igKZgKTtcbiAgICBcbiAgICBjb25zdCBQQUdFX1NJWkUgPSAxMDAwO1xuICAgIGxldCBsYXN0SWQgPSBcIlwiOyAgICAgICAgICAgIC8vIGN1cnNvcjogc3RhcnQgYmVmb3JlIHRoZSBmaXJzdCB0b2tlblxuICAgIGNvbnN0IGhvbGRlcnMgPSBuZXcgU2V0KCk7XG5cbiAgICBjb25zdCBRVUVSWSA9IGBcbiAgICAgIHF1ZXJ5IGhvbGRlcnMoJGJsb2NrOiBJbnQhLCAkbGFzdElkOiBTdHJpbmchKSB7XG4gICAgICAgIHRva2VucyhcbiAgICAgICAgICBmaXJzdDogJHtQQUdFX1NJWkV9LFxuICAgICAgICAgIHdoZXJlOiB7IGlkX2d0OiAkbGFzdElkIH0sXG4gICAgICAgICAgYmxvY2s6IHsgbnVtYmVyOiAkYmxvY2sgfSxcbiAgICAgICAgICBvcmRlckJ5OiBpZCxcbiAgICAgICAgICBvcmRlckRpcmVjdGlvbjogYXNjXG4gICAgICAgICkge1xuICAgICAgICAgIGlkXG4gICAgICAgICAgb3duZXIgeyBpZCB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBgO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyB0b2tlbnMgYWZ0ZXIgaWQ9JyR7bGFzdElkfSfigKZgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChHUkFQSF9VUkwsIHtcbiAgICAgICAgcXVlcnk6IFFVRVJZLFxuICAgICAgICB2YXJpYWJsZXM6IHsgYmxvY2s6IGJsb2NrTnVtYmVyLCBsYXN0SWQgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXNwb25zZS5kYXRhLmVycm9ycykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiR3JhcGhRTCBlcnJvcnM6XCIsIHJlc3BvbnNlLmRhdGEuZXJyb3JzKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR3JhcGhRTCBxdWVyeSBmYWlsZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRva2VucyA9IHJlc3BvbnNlLmRhdGEuZGF0YS50b2tlbnM7XG4gICAgICBpZiAoIXRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJObyBtb3JlIHRva2VucyB0byBmZXRjaFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBlYWNoIG93bmVyIHRvIG91ciBTZXRcbiAgICAgIHRva2Vucy5mb3JFYWNoKHQgPT4gaG9sZGVycy5hZGQodC5vd25lci5pZC50b0xvd2VyQ2FzZSgpKSk7XG5cbiAgICAgIC8vIEFkdmFuY2UgY3Vyc29yIHRvIHRoZSBsYXN0IHRva2VuIElEIG9mIHRoaXMgcGFnZVxuICAgICAgbGFzdElkID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5pZDtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgICDihpIgRmV0Y2hlZCAke3Rva2Vucy5sZW5ndGh9IHRva2VuczsgdW5pcXVlIG93bmVycyBzbyBmYXI6ICR7aG9sZGVycy5zaXplfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7aG9sZGVycy5zaXplfSB0b3RhbCB1bmlxdWUgQkFZQyBob2xkZXJzYCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaG9sZGVycyk7XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgQkFZQyBob2xkZXJzIHZpYSBzdWJncmFwaDpcIiwgZXJyb3IpO1xuICAgIC8vIGZhbGxiYWNrIHRvIHRyYW5zZmVyLWhpc3RvcnkgbWV0aG9kXG4gICAgcmV0dXJuIGdldEhvbGRlcnNGcm9tVG9rZW5UcmFuc2ZlcnMoYmxvY2tOdW1iZXIpO1xuICB9XG59XG5cbi8qKlxuICogRmFsbGJhY2sgbWV0aG9kIHRvIGdldCBob2xkZXJzIGZyb20gdG9rZW4gdHJhbnNmZXJzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEhvbGRlcnNGcm9tVG9rZW5UcmFuc2ZlcnMoYmxvY2tOdW1iZXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnRmFsbGluZyBiYWNrIHRvIHRva2VuIHRyYW5zZmVycyBtZXRob2QnKTtcbiAgICBcbiAgICAvLyBUcmFjayBvd25lcnNoaXAgdXNpbmcgdHJhbnNmZXIgaGlzdG9yeVxuICAgIGNvbnN0IG93bmVyc2hpcE1hcCA9IG5ldyBNYXAoKTtcbiAgICBsZXQgcGFnZSA9IDE7XG4gICAgbGV0IGhhc01vcmVEYXRhID0gdHJ1ZTtcbiAgICBcbiAgICB3aGlsZSAoaGFzTW9yZURhdGEgJiYgcGFnZSA8PSA1KSB7IC8vIExpbWl0IHRvIDUgcGFnZXMgZm9yIHBlcmZvcm1hbmNlXG4gICAgICAvLyBGZXRjaCB0b2tlbiB0cmFuc2ZlcnMgZnJvbSBFdGhlcnNjYW5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KEVUSEVSU0NBTl9BUElfVVJMLCB7XG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIG1vZHVsZTogJ2FjY291bnQnLFxuICAgICAgICAgIGFjdGlvbjogJ3Rva2VubmZ0dHgnLFxuICAgICAgICAgIGNvbnRyYWN0YWRkcmVzczogQkFZQ19DT05UUkFDVF9BRERSRVNTLFxuICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgb2Zmc2V0OiAxMDAsIC8vIDEwMCB0cmFuc2ZlcnMgcGVyIHBhZ2VcbiAgICAgICAgICBzb3J0OiAnYXNjJyxcbiAgICAgICAgICBhcGlrZXk6IEVUSEVSU0NBTl9BUElfS0VZXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YS5zdGF0dXMgIT09ICcxJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFdGhlcnNjYW4gQVBJIGVycm9yOiAke3Jlc3BvbnNlLmRhdGEubWVzc2FnZX1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHRyYW5zZmVycyA9IHJlc3BvbnNlLmRhdGEucmVzdWx0O1xuICAgICAgY29uc29sZS5sb2coYFJldHJpZXZlZCAke3RyYW5zZmVycy5sZW5ndGh9IHRyYW5zZmVycyAocGFnZSAke3BhZ2V9KWApO1xuICAgICAgXG4gICAgICBpZiAodHJhbnNmZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBoYXNNb3JlRGF0YSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyB0cmFuc2ZlcnNcbiAgICAgIGZvciAoY29uc3QgdHJhbnNmZXIgb2YgdHJhbnNmZXJzKSB7XG4gICAgICAgIC8vIFNraXAgdHJhbnNmZXJzIGFmdGVyIG91ciB0YXJnZXQgYmxvY2tcbiAgICAgICAgaWYgKHBhcnNlSW50KHRyYW5zZmVyLmJsb2NrTnVtYmVyKSA+IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgaGFzTW9yZURhdGEgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgdG9rZW5JZCA9IHRyYW5zZmVyLnRva2VuSUQ7XG4gICAgICAgIGNvbnN0IGZyb20gPSB0cmFuc2Zlci5mcm9tLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHRvID0gdHJhbnNmZXIudG8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNraXAgdG9rZW4gbWludGluZyAoZnJvbSB6ZXJvIGFkZHJlc3MpXG4gICAgICAgIGlmIChmcm9tICE9PSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgICAgIC8vIFJlbW92ZSB0b2tlbiBmcm9tIHByZXZpb3VzIG93bmVyXG4gICAgICAgICAgaWYgKG93bmVyc2hpcE1hcC5oYXMoZnJvbSkpIHtcbiAgICAgICAgICAgIG93bmVyc2hpcE1hcC5nZXQoZnJvbSkuZGVsZXRlKHRva2VuSWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB0aGUgb3duZXIgaGFzIG5vIG1vcmUgdG9rZW5zLCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXBcbiAgICAgICAgICAgIGlmIChvd25lcnNoaXBNYXAuZ2V0KGZyb20pLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgb3duZXJzaGlwTWFwLmRlbGV0ZShmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCB0b2tlbiB0byBuZXcgb3duZXJcbiAgICAgICAgaWYgKCFvd25lcnNoaXBNYXAuaGFzKHRvKSkge1xuICAgICAgICAgIG93bmVyc2hpcE1hcC5zZXQodG8sIG5ldyBTZXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3duZXJzaGlwTWFwLmdldCh0bykuYWRkKHRva2VuSWQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBwYWdlKys7XG4gICAgfVxuICAgIFxuICAgIC8vIEV4dHJhY3QgaG9sZGVycyBhdCB0aGlzIGJsb2NrXG4gICAgY29uc3QgaG9sZGVycyA9IEFycmF5LmZyb20ob3duZXJzaGlwTWFwLmtleXMoKSkuZmlsdGVyKFxuICAgICAgYWRkcmVzcyA9PiBhZGRyZXNzICE9PSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICAgICk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYEZvdW5kICR7aG9sZGVycy5sZW5ndGh9IEJBWUMgaG9sZGVycyBmcm9tIGhpc3RvcmljYWwgdHJhbnNmZXJzYCk7XG4gICAgcmV0dXJuIGhvbGRlcnM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igd2l0aCB0b2tlbiB0cmFuc2ZlcnMgbWV0aG9kOicsIGVycm9yKTtcbiAgICByZXR1cm4gRkFMTEJBQ0tfREVNT19EQVRBLnNhbXBsZUhvbGRlcnM7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgRVRIIGJhbGFuY2VzIGZvciBtdWx0aXBsZSBhZGRyZXNzZXMgaW4gYSBzaW5nbGUgbXVsdGljYWxsXG4gKiBUaGlzIGlzIHRoZSBrZXkgb3B0aW1pemF0aW9uIG9mIHRoaXMgaW1wbGVtZW50YXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RXRoQmFsYW5jZXNNdWx0aWNhbGwoYWRkcmVzc2VzLCBibG9ja051bWJlcikge1xuICBpZiAoIW11bHRpY2FsbENvbnRyYWN0KSB7XG4gICAgbXVsdGljYWxsQ29udHJhY3QgPSBpbml0TXVsdGljYWxsKCk7XG4gICAgaWYgKCFtdWx0aWNhbGxDb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBtdWx0aWNhbGwgY29udHJhY3QnKTtcbiAgICB9XG4gIH1cbiAgXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYEdldHRpbmcgRVRIIGJhbGFuY2VzIGZvciAke2FkZHJlc3Nlcy5sZW5ndGh9IGFkZHJlc3NlcyB3aXRoIE11bHRpY2FsbC4uLmApO1xuICAgIFxuICAgIC8vIEJyZWFrIGFkZHJlc3NlcyBpbnRvIGNodW5rcyBvZiA1MDAgdG8gYXZvaWQgZ2FzIGxpbWl0IGlzc3Vlc1xuICAgIGNvbnN0IGNodW5rU2l6ZSA9IDUwMDtcbiAgICBjb25zdCBiYWxhbmNlcyA9IFtdO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzc2VzLmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gYWRkcmVzc2VzLnNsaWNlKGksIGkgKyBjaHVua1NpemUpO1xuICAgICAgY29uc29sZS5sb2coYFByb2Nlc3NpbmcgY2h1bmsgJHtNYXRoLmZsb29yKGkvY2h1bmtTaXplKSArIDF9LyR7TWF0aC5jZWlsKGFkZHJlc3Nlcy5sZW5ndGgvY2h1bmtTaXplKX0gKCR7Y2h1bmsubGVuZ3RofSBhZGRyZXNzZXMpYCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBjYWxscyBhcnJheSBmb3IgbXVsdGljYWxsXG4gICAgICBjb25zdCBjYWxscyA9IGNodW5rLm1hcChhZGRyZXNzID0+ICh7XG4gICAgICAgIHRhcmdldDogTVVMVElDQUxMX0FERFJFU1MsXG4gICAgICAgIGFsbG93RmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgY2FsbERhdGE6IG11bHRpY2FsbENvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoJ2dldEV0aEJhbGFuY2UnLCBbYWRkcmVzc10pXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIC8vIEV4ZWN1dGUgbXVsdGljYWxsXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgbXVsdGljYWxsQ29udHJhY3QuYWdncmVnYXRlMyhjYWxscywgeyBibG9ja1RhZzogYmxvY2tOdW1iZXIgfSk7XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgcmVzdWx0c1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZXN1bHRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNbal07XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gZXRoZXJzLnV0aWxzLmRlZmF1bHRBYmlDb2Rlci5kZWNvZGUoWyd1aW50MjU2J10sIHJlc3VsdC5yZXR1cm5EYXRhKVswXTtcbiAgICAgICAgICAgIGJhbGFuY2VzLnB1c2goYmFsYW5jZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlY29kaW5nIGJhbGFuY2UgcmVzdWx0IGZvciBhZGRyZXNzICR7Y2h1bmtbal19OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgYmFsYW5jZXMucHVzaChldGhlcnMuQmlnTnVtYmVyLmZyb20oMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBnZXQgYmFsYW5jZSBmb3IgYWRkcmVzcyAke2NodW5rW2pdfWApO1xuICAgICAgICAgIGJhbGFuY2VzLnB1c2goZXRoZXJzLkJpZ051bWJlci5mcm9tKDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYmFsYW5jZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gbXVsdGljYWxsIGdldEV0aEJhbGFuY2VzOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBGYWxsYmFjayB0byByZWd1bGFyIGJhbGFuY2UgZmV0Y2hpbmcgaWYgbXVsdGljYWxsIGZhaWxzXG4gICAgY29uc29sZS5sb2coJ011bHRpY2FsbCBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBpbmRpdmlkdWFsIGJhbGFuY2UgcXVlcmllcy4uLicpO1xuICAgIHJldHVybiBnZXRGYWxsYmFja0JhbGFuY2VzKGFkZHJlc3NlcywgYmxvY2tOdW1iZXIpO1xuICB9XG59XG5cbi8qKlxuICogRmFsbGJhY2sgbWV0aG9kIHRvIGdldCBiYWxhbmNlcyBpbmRpdmlkdWFsbHkgaWYgbXVsdGljYWxsIGZhaWxzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEZhbGxiYWNrQmFsYW5jZXMoYWRkcmVzc2VzLCBibG9ja051bWJlcikge1xuICBjb25zb2xlLmxvZyhgR2V0dGluZyBiYWxhbmNlcyBpbmRpdmlkdWFsbHkgZm9yICR7YWRkcmVzc2VzLmxlbmd0aH0gYWRkcmVzc2VzLi4uYCk7XG4gIFxuICBjb25zdCBiYWxhbmNlcyA9IFtdO1xuICBjb25zdCBiYXRjaFNpemUgPSAxMDsgLy8gUHJvY2VzcyBpbiBzbWFsbCBiYXRjaGVzXG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3Nlcy5sZW5ndGg7IGkgKz0gYmF0Y2hTaXplKSB7XG4gICAgY29uc3QgYmF0Y2ggPSBhZGRyZXNzZXMuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSk7XG4gICAgXG4gICAgLy8gUHJvY2VzcyBiYXRjaCBjb25jdXJyZW50bHlcbiAgICBjb25zdCBiYXRjaFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGJhdGNoLm1hcChhc3luYyAoYWRkcmVzcykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKGFkZHJlc3MsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBnZXR0aW5nIGJhbGFuY2UgZm9yICR7YWRkcmVzc306YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgcmV0dXJuIGV0aGVycy5CaWdOdW1iZXIuZnJvbSgwKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIFxuICAgIGJhbGFuY2VzLnB1c2goLi4uYmF0Y2hSZXN1bHRzKTtcbiAgICBcbiAgICBpZiAoaSAlIDUwID09PSAwICYmIGkgPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2VkICR7aX0vJHthZGRyZXNzZXMubGVuZ3RofSBhZGRyZXNzZXMuLi5gKTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBiYWxhbmNlcztcbn1cblxuLyoqXG4gKiBTYXZlIHJlc3VsdHMgdG8gZmlsZSBmb3IgcGVyc2lzdGVuY2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2F2ZVJlc3VsdHNUb0ZpbGUoaW1wbGVtZW50YXRpb25JZCwgdGltZXN0YW1wLCByZXN1bHQpIHtcbiAgdHJ5IHtcbiAgICAvLyBDcmVhdGUgZGlyZWN0b3J5IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoUkVTVUxUU19GSUxFX1BBVEgpO1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgICBmcy5ta2RpclN5bmMoZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVhZCBleGlzdGluZyByZXN1bHRzIG9yIGNyZWF0ZSBuZXcgb2JqZWN0XG4gICAgbGV0IHJlc3VsdHMgPSB7fTtcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhSRVNVTFRTX0ZJTEVfUEFUSCkpIHtcbiAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKFJFU1VMVFNfRklMRV9QQVRILCAndXRmOCcpO1xuICAgICAgcmVzdWx0cyA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgbmV3IHJlc3VsdFxuICAgIGlmICghcmVzdWx0c1tpbXBsZW1lbnRhdGlvbklkXSkge1xuICAgICAgcmVzdWx0c1tpbXBsZW1lbnRhdGlvbklkXSA9IHt9O1xuICAgIH1cbiAgICBcbiAgICAvLyBDb252ZXJ0IEJpZ051bWJlciB0byBzdHJpbmcgZm9yIEpTT04gc3RvcmFnZVxuICAgIGNvbnN0IHJlc3VsdFRvU2F2ZSA9IHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIHRvdGFsV2VpOiByZXN1bHQudG90YWxXZWkudG9TdHJpbmcoKSxcbiAgICAgIGV4ZWN1dGlvblRpbWU6IHJlc3VsdC5leGVjdXRpb25UaW1lLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9O1xuICAgIFxuICAgIHJlc3VsdHNbaW1wbGVtZW50YXRpb25JZF1bdGltZXN0YW1wXSA9IHJlc3VsdFRvU2F2ZTtcbiAgICBcbiAgICAvLyBXcml0ZSBiYWNrIHRvIGZpbGVcbiAgICBmcy53cml0ZUZpbGVTeW5jKFJFU1VMVFNfRklMRV9QQVRILCBKU09OLnN0cmluZ2lmeShyZXN1bHRzLCBudWxsLCAyKSk7XG4gICAgY29uc29sZS5sb2coYFJlc3VsdHMgc2F2ZWQgdG8gJHtSRVNVTFRTX0ZJTEVfUEFUSH1gKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgcmVzdWx0cyB0byBmaWxlOicsIGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBwcmV2aW91cyByZXN1bHRzIGZyb20gY2FjaGUgZmlsZVxuICovXG5mdW5jdGlvbiBnZXRQcmV2aW91c1Jlc3VsdHMoKSB7XG4gIHRyeSB7XG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoUkVTVUxUU19GSUxFX1BBVEgpKSB7XG4gICAgICBjb25zdCBmaWxlQ29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhSRVNVTFRTX0ZJTEVfUEFUSCwgJ3V0ZjgnKTtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGZpbGVDb250ZW50KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVhZGluZyBwcmV2aW91cyByZXN1bHRzOicsIGVycm9yKTtcbiAgfVxuICByZXR1cm4ge307XG59XG5cbi8qKlxuICogR2V0IHRvdGFsIEVUSCB2YWx1ZSBvZiBhbGwgQkFZQyBob2xkZXJzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFRvdGFsRXRoVmFsdWVPZkhvbGRlcnModGltZXN0YW1wKSB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIFxuICB0cnkge1xuICAgIC8vIFN0ZXAgMTogR2V0IGJsb2NrIG51bWJlciBhdCB0aW1lc3RhbXBcbiAgICBjb25zdCBibG9ja051bWJlciA9IGF3YWl0IGdldEJsb2NrTnVtYmVyQXRUaW1lc3RhbXAodGltZXN0YW1wKTtcbiAgICBjb25zb2xlLmxvZyhgVXNpbmcgYmxvY2sgbnVtYmVyICR7YmxvY2tOdW1iZXJ9IGZvciB0aW1lc3RhbXAgJHt0aW1lc3RhbXB9YCk7XG4gICAgXG4gICAgLy8gU3RlcCAyOiBHZXQgQkFZQyBob2xkZXJzIGF0IHRoYXQgYmxvY2tcbiAgICBjb25zdCBob2xkZXJzID0gYXdhaXQgZ2V0QkFZQ0hvbGRlcnNBdEJsb2NrKGJsb2NrTnVtYmVyKTtcbiAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtob2xkZXJzLmxlbmd0aH0gQkFZQyBob2xkZXJzIGF0IHRoaXMgYmxvY2tgKTtcbiAgICBcbiAgICAvLyBTdGVwIDM6IEdldCBFVEggYmFsYW5jZXMgb2YgYWxsIGhvbGRlcnNcbiAgICBjb25zdCBiYWxhbmNlcyA9IGF3YWl0IGdldEV0aEJhbGFuY2VzTXVsdGljYWxsKGhvbGRlcnMsIGJsb2NrTnVtYmVyKTtcbiAgICBjb25zb2xlLmxvZyhgUmV0cmlldmVkICR7YmFsYW5jZXMubGVuZ3RofSBiYWxhbmNlc2ApO1xuICAgIFxuICAgIGlmIChiYWxhbmNlcy5sZW5ndGggIT09IGhvbGRlcnMubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6IE51bWJlciBvZiBiYWxhbmNlcyAoJHtiYWxhbmNlcy5sZW5ndGh9KSBkb2Vzbid0IG1hdGNoIGhvbGRlcnMgKCR7aG9sZGVycy5sZW5ndGh9KWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGVwIDQ6IFN1bSB0b3RhbCBFVEggdmFsdWVcbiAgICBjb25zdCB0b3RhbFdlaSA9IGJhbGFuY2VzLnJlZHVjZSgoc3VtLCBiYWxhbmNlKSA9PiBzdW0uYWRkKGJhbGFuY2UpLCBldGhlcnMuQmlnTnVtYmVyLmZyb20oMCkpO1xuICAgIGNvbnN0IHRvdGFsRXRoID0gZXRoZXJzLnV0aWxzLmZvcm1hdEV0aGVyKHRvdGFsV2VpKTtcbiAgICBcbiAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBjb25zb2xlLmxvZyhgVG90YWwgRVRIIHZhbHVlOiAke3RvdGFsRXRofSBFVEggKGV4ZWN1dGlvbiB0aW1lOiAke2V4ZWN1dGlvblRpbWV9bXMpYCk7XG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgYmxvY2tOdW1iZXIsXG4gICAgICBob2xkZXJDb3VudDogaG9sZGVycy5sZW5ndGgsXG4gICAgICB0b3RhbFdlaSxcbiAgICAgIHRvdGFsRXRoLFxuICAgICAgZXhlY3V0aW9uVGltZSxcbiAgICAgIG1ldGhvZDogJ1RoZSBHcmFwaCcsIC8vIEFkZGluZyBtZXRob2QgdXNlZCBmb3IgaG9sZGVycyBkYXRhIGZvciBjb21wYXJpc29uXG4gICAgICBpbXBsZW1lbnRhdGlvbjogJ211bHRpY2FsbCdcbiAgICB9O1xuICAgIFxuICAgIC8vIFNhdmUgcmVzdWx0cyBmb3IgcGVyc2lzdGVuY2VcbiAgICBhd2FpdCBzYXZlUmVzdWx0c1RvRmlsZSgnbXVsdGljYWxsJywgdGltZXN0YW1wLCByZXN1bHQpO1xuICAgIFxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsY3VsYXRpbmcgdG90YWwgRVRIIHZhbHVlOicsIGVycm9yKTtcbiAgICBjb25zdCBleGVjdXRpb25UaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBibG9ja051bWJlcjogMCxcbiAgICAgIGhvbGRlckNvdW50OiAwLFxuICAgICAgdG90YWxXZWk6IGV0aGVycy5CaWdOdW1iZXIuZnJvbSgwKSxcbiAgICAgIHRvdGFsRXRoOiBcIjBcIixcbiAgICAgIGV4ZWN1dGlvblRpbWUsXG4gICAgICBtZXRob2Q6ICdUaGUgR3JhcGggKGVycm9yZWQpJyxcbiAgICAgIGltcGxlbWVudGF0aW9uOiAnbXVsdGljYWxsJ1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihyZXEsIHJlcykge1xuICBpZiAocmVxLm1ldGhvZCAhPT0gJ1BPU1QnKSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgbWVzc2FnZTogJ01ldGhvZCBub3QgYWxsb3dlZCcgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgdGltZXN0YW1wIH0gPSByZXEuYm9keTtcbiAgICBpZiAoIXRpbWVzdGFtcCkge1xuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgbWVzc2FnZTogJ1RpbWVzdGFtcCBpcyByZXF1aXJlZCcgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgY2FjaGVkIHJlc3VsdHNcbiAgICBjb25zdCBwcmV2aW91c1Jlc3VsdHMgPSBnZXRQcmV2aW91c1Jlc3VsdHMoKTtcbiAgICBjb25zdCBjYWNoZWRSZXN1bHQgPSBwcmV2aW91c1Jlc3VsdHM/LlsnbXVsdGljYWxsJ10/Llt0aW1lc3RhbXBdO1xuICAgIFxuICAgIGlmIChjYWNoZWRSZXN1bHQgJiYgcmVxLmJvZHkudXNlQ2FjaGUgIT09IGZhbHNlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgVXNpbmcgY2FjaGVkIHJlc3VsdCBmb3IgdGltZXN0YW1wICR7dGltZXN0YW1wfWApO1xuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IHN0cmluZyBiYWNrIHRvIEJpZ051bWJlciBmb3IgY29uc2lzdGVuY3lcbiAgICAgIGNhY2hlZFJlc3VsdC50b3RhbFdlaSA9IGV0aGVycy5CaWdOdW1iZXIuZnJvbShjYWNoZWRSZXN1bHQudG90YWxXZWkpO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgICAuLi5jYWNoZWRSZXN1bHQsXG4gICAgICAgIGZyb21DYWNoZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VG90YWxFdGhWYWx1ZU9mSG9sZGVycyh0aW1lc3RhbXApO1xuICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbihyZXN1bHQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIG11bHRpY2FsbCBBUEkgaGFuZGxlcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgXG4gICAgICBtZXNzYWdlOiAnRXJyb3IgcHJvY2Vzc2luZyByZXF1ZXN0JywgXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSBcbiAgICB9KTtcbiAgfVxufSAiXSwibmFtZXMiOlsiZXRoZXJzIiwiYXhpb3MiLCJmcyIsInBhdGgiLCJCQVlDX0NPTlRSQUNUX0FERFJFU1MiLCJFVEhFUlNDQU5fQVBJX1VSTCIsIkVUSEVSU0NBTl9BUElfS0VZIiwicHJvY2VzcyIsImVudiIsIkFMQ0hFTVlfQVBJX0tFWSIsIkFMQ0hFTVlfQVBJX1VSTCIsIk1VTFRJQ0FMTF9BRERSRVNTIiwiTVVMVElDQUxMX0FCSSIsIkdSQVBIX1VSTCIsIkJBWUNfU1VCR1JBUEhfVVJMIiwiU1RBVElDX1BST1ZJREVSIiwicHJvdmlkZXJzIiwiU3RhdGljSnNvblJwY1Byb3ZpZGVyIiwiUkVTVUxUU19GSUxFX1BBVEgiLCJqb2luIiwiY3dkIiwiRkFMTEJBQ0tfREVNT19EQVRBIiwiYmxvY2tzIiwic2FtcGxlSG9sZGVycyIsInByb3ZpZGVyIiwibXVsdGljYWxsQ29udHJhY3QiLCJpbml0UHJvdmlkZXIiLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJtZXNzYWdlIiwiaW5pdE11bHRpY2FsbCIsInAiLCJDb250cmFjdCIsImhhc0ZhbGxiYWNrRGF0YSIsInRpbWVzdGFtcCIsIk9iamVjdCIsImtleXMiLCJzb21lIiwidCIsIk1hdGgiLCJhYnMiLCJwYXJzZUludCIsImdldEZhbGxiYWNrQmxvY2tOdW1iZXIiLCJ0aW1lc3RhbXBzIiwibWFwIiwiTnVtYmVyIiwiY2xvc2VzdCIsIm1pbkRpZmYiLCJpIiwibGVuZ3RoIiwiZGlmZiIsImdldEJsb2NrTnVtYmVyQXRUaW1lc3RhbXAiLCJsb3ciLCJoaWdoIiwiZ2V0QmxvY2tOdW1iZXIiLCJyZXN1bHQiLCJtaWQiLCJmbG9vciIsImJsb2NrIiwiZ2V0QmxvY2siLCJyZXNwb25zZSIsImdldCIsInBhcmFtcyIsIm1vZHVsZSIsImFjdGlvbiIsImFwaWtleSIsImRhdGEiLCJzdGF0dXMiLCJFcnJvciIsInNlY29uZGFyeUVycm9yIiwiZ2V0QkFZQ0hvbGRlcnNBdEJsb2NrIiwiYmxvY2tOdW1iZXIiLCJQQUdFX1NJWkUiLCJsYXN0SWQiLCJob2xkZXJzIiwiU2V0IiwiUVVFUlkiLCJwb3N0IiwicXVlcnkiLCJ2YXJpYWJsZXMiLCJlcnJvcnMiLCJ0b2tlbnMiLCJmb3JFYWNoIiwiYWRkIiwib3duZXIiLCJpZCIsInRvTG93ZXJDYXNlIiwic2l6ZSIsIkFycmF5IiwiZnJvbSIsImdldEhvbGRlcnNGcm9tVG9rZW5UcmFuc2ZlcnMiLCJvd25lcnNoaXBNYXAiLCJNYXAiLCJwYWdlIiwiaGFzTW9yZURhdGEiLCJjb250cmFjdGFkZHJlc3MiLCJvZmZzZXQiLCJzb3J0IiwidHJhbnNmZXJzIiwidHJhbnNmZXIiLCJ0b2tlbklkIiwidG9rZW5JRCIsInRvIiwiaGFzIiwiZGVsZXRlIiwic2V0IiwiZmlsdGVyIiwiYWRkcmVzcyIsImdldEV0aEJhbGFuY2VzTXVsdGljYWxsIiwiYWRkcmVzc2VzIiwiY2h1bmtTaXplIiwiYmFsYW5jZXMiLCJjaHVuayIsInNsaWNlIiwiY2VpbCIsImNhbGxzIiwidGFyZ2V0IiwiYWxsb3dGYWlsdXJlIiwiY2FsbERhdGEiLCJpbnRlcmZhY2UiLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJyZXN1bHRzIiwiYWdncmVnYXRlMyIsImJsb2NrVGFnIiwiaiIsInN1Y2Nlc3MiLCJiYWxhbmNlIiwidXRpbHMiLCJkZWZhdWx0QWJpQ29kZXIiLCJkZWNvZGUiLCJyZXR1cm5EYXRhIiwicHVzaCIsIkJpZ051bWJlciIsIndhcm4iLCJnZXRGYWxsYmFja0JhbGFuY2VzIiwiYmF0Y2hTaXplIiwiYmF0Y2giLCJiYXRjaFJlc3VsdHMiLCJQcm9taXNlIiwiYWxsIiwiZ2V0QmFsYW5jZSIsInNhdmVSZXN1bHRzVG9GaWxlIiwiaW1wbGVtZW50YXRpb25JZCIsImRpciIsImRpcm5hbWUiLCJleGlzdHNTeW5jIiwibWtkaXJTeW5jIiwicmVjdXJzaXZlIiwiZmlsZUNvbnRlbnQiLCJyZWFkRmlsZVN5bmMiLCJKU09OIiwicGFyc2UiLCJyZXN1bHRUb1NhdmUiLCJ0b3RhbFdlaSIsInRvU3RyaW5nIiwiZXhlY3V0aW9uVGltZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIndyaXRlRmlsZVN5bmMiLCJzdHJpbmdpZnkiLCJnZXRQcmV2aW91c1Jlc3VsdHMiLCJnZXRUb3RhbEV0aFZhbHVlT2ZIb2xkZXJzIiwic3RhcnRUaW1lIiwibm93IiwicmVkdWNlIiwic3VtIiwidG90YWxFdGgiLCJmb3JtYXRFdGhlciIsImhvbGRlckNvdW50IiwibWV0aG9kIiwiaW1wbGVtZW50YXRpb24iLCJoYW5kbGVyIiwicmVxIiwicmVzIiwianNvbiIsImJvZHkiLCJwcmV2aW91c1Jlc3VsdHMiLCJjYWNoZWRSZXN1bHQiLCJ1c2VDYWNoZSIsImZyb21DYWNoZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/implementations/multicall.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fimplementations%2Fmulticall&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Fimplementations%2Fmulticall.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();